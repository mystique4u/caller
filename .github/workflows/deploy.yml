name: Deploy Infrastructure

on:
  push:
    branches:
      - main
    paths:
      - 'terraform/**'
      - 'ansible/**'
      - '.github/workflows/deploy.yml'
      - '.github/workflows/destroy.yml'
      - '.github/workflows/backup.yml'
      - '.github/workflows/restore.yml'
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
      skip_validation:
        description: 'Skip validation stages (not recommended)'
        required: false
        default: false
        type: boolean

env:
  TERRAFORM_VERSION: '1.6.0'
  # Terraform Cloud authentication (for state storage only)
  TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
  # Variables from GitHub Secrets
  TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
  TF_VAR_firewall_name: ${{ secrets.FIREWALL_NAME }}
  TF_VAR_ssh_key_ids: ${{ secrets.SSH_KEY_IDS }}
  TF_VAR_domain_name: ${{ secrets.DOMAIN_NAME }}
  TF_VAR_server_location: ${{ secrets.TF_VAR_server_location || 'nbg1' }}

jobs:
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.skip_validation != 'true')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Check for secrets in code
        run: |
          echo "ğŸ” Scanning for potential secrets..."
          # Exclude:
          # - .example, .sample, .template files
          # - Comments
          # - Ansible lookup('env', ...) patterns (correct way to use env vars)
          # - GitHub Secrets references
          if grep -r -i -E "(password|secret|api_key|token).*=.*['\"][^'\"]{8,}['\"]" \
            --exclude="*.example" \
            --exclude="*.sample" \
            --exclude="*.template" \
            --exclude="README.md" \
            terraform/ ansible/ 2>/dev/null | \
            grep -v "^[[:space:]]*#" | \
            grep -v "lookup('env'" | \
            grep -v "secrets\." ; then
            echo "::error::Found potential hardcoded secrets in actual code!"
            echo "::error::Use GitHub Secrets instead of hardcoding sensitive values"
            exit 1
          fi
          echo "âœ… No hardcoded secrets detected"
          
      - name: Check file permissions
        run: |
          echo "ğŸ” Checking for executable files..."
          find . -type f -name "*.tf" -executable -o -name "*.yml" -executable -o -name "*.yaml" -executable | while read file; do
            echo "::warning::File should not be executable: $file"
          done
          
      - name: Validate Ansible syntax
        run: |
          echo "ğŸ” Installing Ansible..."
          pip install ansible ansible-lint
          echo "âœ… Checking Ansible playbook syntax..."
          for playbook in ansible/*.yml; do
            if [ -f "$playbook" ]; then
              ansible-playbook --syntax-check "$playbook" || exit 1
            fi
          done
          echo "âœ… Ansible syntax valid"

  terraform-validate:
    name: Terraform Validation
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.skip_validation != 'true')
    defaults:
      run:
        working-directory: ./terraform
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
          
      - name: Terraform Format Check
        id: fmt
        run: |
          echo "ğŸ” Checking Terraform formatting..."
          terraform fmt -check -recursive
          echo "âœ… Terraform files are properly formatted"
        
      - name: Terraform Init
        id: init
        run: |
          echo "ğŸ”§ Initializing Terraform..."
          terraform init
          echo "âœ… Terraform initialized"
        
      - name: Terraform Validate
        id: validate
        run: |
          echo "ğŸ” Validating Terraform configuration..."
          terraform validate -no-color
          echo "âœ… Terraform configuration is valid"
          
      - name: Check for Terraform best practices
        run: |
          echo "ğŸ” Checking Terraform best practices..."
          # Check for variables without descriptions (look for variable blocks without description lines)
          missing_desc=0
          while IFS= read -r line; do
            if echo "$line" | grep -q "^variable"; then
              var_name=$(echo "$line" | sed -n 's/.*"\([^"]*\)".*/\1/p')
              # Read ahead to check if description exists in the next few lines
              context=$(grep -A 5 "^variable \"$var_name\"" main.tf)
              if ! echo "$context" | grep -q "description"; then
                echo "::warning::Variable '$var_name' is missing a description"
                missing_desc=1
              fi
            fi
          done < <(grep "^variable" main.tf)
          
          if [ $missing_desc -eq 0 ]; then
            echo "âœ… All variables have descriptions"
          fi
          echo "âœ… Best practices check complete"

  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.skip_validation != 'true')
    defaults:
      run:
        working-directory: ./terraform
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
          
      - name: Terraform Init
        run: terraform init
        
      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: terraform
          soft_fail: true
          
      - name: Check for common security issues
        run: |
          echo "ğŸ” Checking for common security misconfigurations..."
          
          # Check for SSH (port 22) open to the world - this is a real security risk
          if grep -B5 -A5 "port.*22" main.tf | grep "0.0.0.0/0" | grep -v "#" > /dev/null 2>&1; then
            echo "::warning::SSH port 22 is open to 0.0.0.0/0 - consider restricting to specific IPs"
          fi
          
          # Check for exposed database ports
          for port in 3306 5432 27017 6379 9200; do
            if grep -B5 -A5 "port.*$port" main.tf | grep "0.0.0.0/0" | grep -v "#" > /dev/null 2>&1; then
              echo "::error::Database port $port is exposed to the internet!"
            fi
          done
          
          echo "âœ… Security check complete"

  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [code-quality, terraform-validate, security-scan]
    if: |
      always() &&
      (needs.code-quality.result == 'success' || needs.code-quality.result == 'skipped') &&
      (needs.terraform-validate.result == 'success' || needs.terraform-validate.result == 'skipped') &&
      (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped')
    defaults:
      run:
        working-directory: ./terraform
    
    outputs:
      plan_exitcode: ${{ steps.plan.outputs.exitcode }}
      has_changes: ${{ steps.plan.outputs.exitcode == '2' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
          
      - name: Terraform Init
        run: |
          echo "ğŸ”§ Initializing Terraform..."
          terraform init
        
      - name: Terraform Plan
        id: plan
        run: |
          echo "ğŸ“‹ Creating Terraform plan..."
          set +e  # Don't exit on error
          terraform plan -detailed-exitcode -no-color -out=tfplan
          exitcode=$?
          set -e
          
          echo "exitcode=$exitcode" >> $GITHUB_OUTPUT
          
          # Save plan output for review
          terraform show -no-color tfplan > plan_output.txt 2>&1 || true
          
          # Exit codes: 0 = no changes, 1 = error, 2 = changes detected
          if [ $exitcode -eq 0 ]; then
            echo "âœ… Plan successful - no changes needed"
            exit 0
          elif [ $exitcode -eq 2 ]; then
            echo "âœ… Plan successful - changes detected"
            exit 0
          else
            echo "âŒ Plan failed with error"
            exit 1
          fi
        
      - name: Upload Plan
        if: steps.plan.outputs.exitcode == '2'
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: |
            terraform/tfplan
            terraform/plan_output.txt
          retention-days: 5
          
      - name: Create Plan Summary
        if: steps.plan.outputs.exitcode == '2'
        run: |
          echo "## âœ… Terraform Plan Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** Infrastructure changes detected (this is expected)" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" == "push" ]; then
            echo "**Triggered by:** Push to main" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Changes Preview" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```terraform' >> $GITHUB_STEP_SUMMARY
          head -n 100 plan_output.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" == "push" ]; then
            echo "### ğŸš€ Next Steps" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "To deploy these changes:" >> $GITHUB_STEP_SUMMARY
            echo "1. Review the plan above" >> $GITHUB_STEP_SUMMARY
            echo "2. Go to Actions â†’ Deploy Infrastructure" >> $GITHUB_STEP_SUMMARY
            echo "3. Click 'Run workflow'" >> $GITHUB_STEP_SUMMARY
            echo "4. Select action: **apply**" >> $GITHUB_STEP_SUMMARY
            echo "5. Click 'Run workflow' button" >> $GITHUB_STEP_SUMMARY
          else
            echo "To apply these changes, trigger workflow with 'apply' action." >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Plan Status
        run: |
          exitcode="${{ steps.plan.outputs.exitcode }}"
          echo "Plan exit code: $exitcode (0=no changes, 2=changes detected, 1=error)"
          
          if [ "$exitcode" == "0" ]; then
            echo "âœ… No infrastructure changes detected"
            if [ "${{ github.event_name }}" == "push" ]; then
              echo "::notice::All checks passed. No infrastructure changes needed."
            fi
          elif [ "$exitcode" == "2" ]; then
            echo "âœ… Plan completed successfully - infrastructure changes detected"
            if [ "${{ github.event_name }}" == "push" ]; then
              echo "::notice::âœ… Plan successful! Review the plan and manually trigger 'apply' to deploy."
            else
              echo "::notice::âœ… Plan successful! Run workflow with 'apply' action to deploy."
            fi
          else
            echo "âŒ Plan failed - check logs for details"
            exit 1
          fi

  # Auto-deploy on push (no approval needed)
  terraform-auto:
    name: Terraform Apply (Auto on Push)
    runs-on: ubuntu-latest
    needs: plan
    if: |
      github.event_name == 'push' &&
      needs.plan.result == 'success'
    defaults:
      run:
        working-directory: ./terraform
    
    outputs:
      public_ip: ${{ steps.terraform_output.outputs.public_ip }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
          
      - name: Terraform Init
        run: |
          echo "ğŸ”§ Initializing Terraform..."
          terraform init
        
      - name: Terraform Apply
        id: apply
        run: |
          echo "ğŸš€ Applying Terraform changes (auto-approved on push)..."
          echo "â„¹ï¸ Auto-deploy on push - not using plan artifact"
          terraform apply -auto-approve -input=false
          echo "âœ… Infrastructure deployed successfully"
          
      - name: Get Terraform Outputs
        id: terraform_output
        if: steps.apply.outcome == 'success'
        run: |
          PUBLIC_IP=$(terraform output -raw public_ip)
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "Server IP: $PUBLIC_IP"

  approval-gate:
    name: Deployment Approval Required
    runs-on: ubuntu-latest
    needs: plan
    if: |
      github.event_name == 'workflow_dispatch' && 
      github.event.inputs.action == 'apply' &&
      needs.plan.outputs.plan_exitcode == '2'
    
    steps:
      - name: Approval Notice
        run: |
          echo "ğŸš¦ Deployment requires manual approval"
          echo "Review the Terraform plan in the artifacts before proceeding"
          echo "Changes will be applied to production infrastructure"
          
  terraform:
    name: Terraform Apply (Manual)
    runs-on: ubuntu-latest
    needs: [plan, approval-gate]
    if: |
      always() &&
      github.event_name == 'workflow_dispatch' && 
      github.event.inputs.action == 'apply' &&
      (needs.plan.result == 'success' || needs.plan.result == 'skipped')
    environment:
      name: production
    defaults:
      run:
        working-directory: ./terraform
    
    outputs:
      public_ip: ${{ steps.terraform_output.outputs.public_ip }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
          
      - name: Terraform Init
        run: |
          echo "ğŸ”§ Initializing Terraform..."
          terraform init
        
      - name: Check for Plan Artifact
        id: check_artifact
        continue-on-error: true
        run: |
          echo "Checking if plan artifact exists from this workflow run..."
          # This will be used to decide whether to download
          echo "artifact_expected=true" >> $GITHUB_OUTPUT
        
      - name: Download Plan
        if: steps.check_artifact.outcome == 'success'
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: terraform/
        continue-on-error: true
        id: download_plan
        
      - name: Terraform Apply
        id: apply
        run: |
          echo "ğŸš€ Applying Terraform changes..."
          if [ -f "tfplan" ]; then
            echo "âœ… Using pre-generated plan from this workflow run"
            terraform apply -auto-approve tfplan
          else
            echo "â„¹ï¸ No plan artifact found (manual trigger), generating new plan and applying"
            terraform apply -auto-approve -input=false
          fi
          echo "âœ… Infrastructure deployed successfully"
          
      - name: Get Terraform Outputs
        id: terraform_output
        if: steps.apply.outcome == 'success'
        run: |
          PUBLIC_IP=$(terraform output -raw public_ip)
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "Server IP: $PUBLIC_IP"
          
      - name: Save Terraform Outputs
        if: steps.apply.outcome == 'success'
        run: |
          terraform output -json > outputs.json
          
      - name: Upload Terraform Outputs
        if: steps.apply.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: terraform/outputs.json
          retention-days: 30

  ansible:
    name: Configure Server
    runs-on: ubuntu-latest
    needs: [terraform, terraform-auto]
    if: |
      always() &&
      (
        (needs.terraform.result == 'success' && needs.terraform.outputs.public_ip != '' && github.event_name == 'workflow_dispatch') ||
        (needs.terraform-auto.result == 'success' && needs.terraform-auto.outputs.public_ip != '' && github.event_name == 'push')
      )
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          
      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible
          
      - name: Setup SSH key
        run: |
          SERVER_IP="${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H $SERVER_IP >> ~/.ssh/known_hosts
          
      - name: Create dynamic inventory
        working-directory: ./ansible
        run: |
          SERVER_IP="${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          cat > inventory.ini << EOF
          [wireguard]
          wireguard-vpn-server ansible_host=$SERVER_IP

          [wireguard:vars]
          ansible_user=root
          ansible_python_interpreter=/usr/bin/python3
          ansible_ssh_common_args='-o StrictHostKeyChecking=no'
          EOF
          
      - name: Wait for SSH to be ready
        run: |
          SERVER_IP="${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          for i in {1..30}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 root@$SERVER_IP 'echo SSH is ready'; then
              echo "SSH connection established"
              break
            fi
            echo "Waiting for SSH... attempt $i/30"
            sleep 10
          done
          
      - name: Run Ansible Playbook
        working-directory: ./ansible
        env:
          DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
          EMAIL_ADDRESS: ${{ secrets.EMAIL_ADDRESS }}
          LETSENCRYPT_ENV: ${{ secrets.LETSENCRYPT_ENV || 'production' }}
          JITSI_ADMIN_USER: ${{ secrets.JITSI_ADMIN_USER }}
          JITSI_ADMIN_PASSWORD: ${{ secrets.JITSI_ADMIN_PASSWORD }}
          MATRIX_ADMIN_USER: ${{ secrets.MATRIX_ADMIN_USER }}
          MATRIX_ADMIN_PASSWORD: ${{ secrets.MATRIX_ADMIN_PASSWORD }}
          MATRIX_REGISTRATION_SECRET: ${{ secrets.MATRIX_REGISTRATION_SECRET }}
          MATRIX_POSTGRES_PASSWORD: ${{ secrets.MATRIX_POSTGRES_PASSWORD }}
        run: |
          echo "ğŸ” Let's Encrypt Environment: ${LETSENCRYPT_ENV}"
          if [ "${LETSENCRYPT_ENV}" == "staging" ]; then
            echo "âš ï¸ Using Let's Encrypt STAGING (test certificates - will show browser warnings)"
          else
            echo "âœ… Using Let's Encrypt PRODUCTION (trusted certificates)"
          fi
          
          # Build extra-vars for Ansible
          EXTRA_VARS=""
          if [ -n "$JITSI_ADMIN_USER" ] && [ -n "$JITSI_ADMIN_PASSWORD" ]; then
            EXTRA_VARS="-e jitsi_admin_user=$JITSI_ADMIN_USER -e jitsi_admin_password=$JITSI_ADMIN_PASSWORD"
            echo "âœ… Jitsi admin user will be created: $JITSI_ADMIN_USER"
          else
            echo "âš ï¸ JITSI_ADMIN_USER or JITSI_ADMIN_PASSWORD not set - skipping admin user creation"
          fi
          
          if [ -n "$MATRIX_ADMIN_USER" ] && [ -n "$MATRIX_ADMIN_PASSWORD" ] && [ -n "$MATRIX_REGISTRATION_SECRET" ] && [ -n "$MATRIX_POSTGRES_PASSWORD" ]; then
            EXTRA_VARS="$EXTRA_VARS -e matrix_admin_user=$MATRIX_ADMIN_USER -e matrix_admin_password=$MATRIX_ADMIN_PASSWORD -e matrix_registration_secret=$MATRIX_REGISTRATION_SECRET -e postgres_password=$MATRIX_POSTGRES_PASSWORD"
            echo "âœ… Matrix admin user will be created: $MATRIX_ADMIN_USER"
          else
            echo "âš ï¸ Matrix secrets not fully configured - skipping Matrix deployment"
          fi
          
          # Add Storage Box credentials for backups
          export STORAGEBOX_HOST="${{ secrets.STORAGEBOX_HOST }}"
          export STORAGEBOX_USER="${{ secrets.STORAGEBOX_USER }}"
          export STORAGEBOX_PASSWORD="${{ secrets.STORAGEBOX_PASSWORD }}"
          
          ansible-playbook -i inventory.ini playbook.yml -v $EXTRA_VARS

  health-check:
    name: Post-Deployment Health Checks
    runs-on: ubuntu-latest
    needs: [terraform, terraform-auto, ansible]
    if: |
      always() &&
      needs.ansible.result == 'success'
    
    steps:
      - name: Wait for services to initialize
        run: |
          echo "â³ Waiting 60 seconds for services to fully initialize..."
          sleep 60
          
      - name: Setup SSH key
        run: |
          SERVER_IP="${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H $SERVER_IP >> ~/.ssh/known_hosts
          
      - name: Check Docker services on server
        run: |
          SERVER_IP="${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          echo "ğŸ” Checking Docker containers status..."
          ssh -o StrictHostKeyChecking=no root@$SERVER_IP << 'EOF'
            echo "=== Docker Container Status ==="
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            echo ""
            
            echo "=== Checking if core services are running ==="
            # Core services that should always be running
            core_containers="traefik wireguard-ui jitsi-web jitsi-prosody jitsi-jicofo jitsi-jvb"
            all_running=true
            
            for container in $core_containers; do
              if docker ps --filter "name=$container" --filter "status=running" | grep -q "$container"; then
                echo "âœ… $container is running"
              else
                echo "âŒ $container is NOT running"
                all_running=false
              fi
            done
            
            echo ""
            echo "=== Checking optional Matrix services ==="
            optional_containers="matrix-postgres matrix-synapse element-web"
            
            for container in $optional_containers; do
              if docker ps --filter "name=$container" --filter "status=running" | grep -q "$container"; then
                echo "âœ… $container is running"
              else
                echo "â„¹ï¸  $container is not running (optional - requires GitHub Secrets configuration)"
              fi
            done
            
            echo ""
            echo "=== Docker Compose Logs (last 20 lines) ==="
            cd /opt/services
            docker compose logs --tail=20
            
            if [ "$all_running" = false ]; then
              echo "ERROR: One or more core services are not running!"
              exit 1
            fi
            
            echo ""
            echo "âœ… All core services are healthy!"
          EOF
          
      - name: Check Traefik routing and labels
        run: |
          SERVER_IP="${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          echo "ğŸ” Checking Traefik labels and configuration..."
          ssh -o StrictHostKeyChecking=no root@$SERVER_IP << 'EOF'
            echo "=== WireGuard UI Labels ==="
            docker inspect wireguard-ui --format='{{range $key, $value := .Config.Labels}}{{$key}}={{$value}}{{"\n"}}{{end}}' | grep traefik || echo "No Traefik labels found!"
            
            echo ""
            echo "=== Jitsi Meet Labels ==="
            docker inspect jitsi-web --format='{{range $key, $value := .Config.Labels}}{{$key}}={{$value}}{{"\n"}}{{end}}' | grep traefik || echo "No Traefik labels found!"
            
            echo ""
            echo "=== Matrix Synapse Labels ==="
            docker inspect matrix-synapse --format='{{range $key, $value := .Config.Labels}}{{$key}}={{$value}}{{"\n"}}{{end}}' | grep traefik 2>/dev/null || echo "Matrix not deployed (requires secrets)"
            
            echo ""
      - name: Check DNS resolution
        run: |
          domain="${{ secrets.DOMAIN_NAME }}"
          echo "ğŸ” Checking DNS resolution for $domain..."
          
          echo "=== Root Domain ==="
          dig +short "$domain" || echo "âš ï¸ DNS not resolved yet"
          
          echo "=== VPN Subdomain ==="
          dig +short "vpn.$domain" || echo "âš ï¸ DNS not resolved yet"
          
          echo "=== Meet Subdomain ==="
          dig +short "meet.$domain" || echo "âš ï¸ DNS not resolved yet"
          
          echo "=== Matrix Subdomain ==="
          dig +short "matrix.$domain" || echo "âš ï¸ DNS not resolved yet"
          
          echo "=== Chat Subdomain (Element) ==="
          dig +short "chat.$domain" || echo "âš ï¸ DNS not resolved yet"
          
          echo ""
          echo "Expected IP: ${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          echo "=== VPN Subdomain ==="
          dig +short "vpn.$domain" || echo "âš ï¸ DNS not resolved yet"
          
          echo "=== Meet Subdomain ==="
          dig +short "meet.$domain" || echo "âš ï¸ DNS not resolved yet"
          
          echo ""
          echo "Expected IP: ${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          
      - name: Check HTTPS services
        run: |
          domain="${{ secrets.DOMAIN_NAME }}"
          ip="${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          
          echo "ğŸ” Checking HTTPS endpoints..."
          
          # Check root domain
          echo "Testing https://$domain ..."
          if curl -sSf -k --connect-timeout 10 "https://$domain" > /dev/null 2>&1; then
            echo "âœ… Root domain is accessible"
          else
            echo "::warning::Root domain https://$domain is not responding yet (SSL may still be provisioning)"
          fi
          
          # Check WireGuard UI subdomain
          echo "Testing https://vpn.$domain ..."
          if curl -sSf -k --connect-timeout 10 "https://vpn.$domain" > /dev/null 2>&1; then
            echo "âœ… WireGuard UI is accessible at https://vpn.$domain"
          else
            echo "::warning::WireGuard UI at https://vpn.$domain is not responding yet"
          fi
          
          # Check Jitsi Meet subdomain
          echo "Testing https://meet.$domain ..."
          if curl -sSf -k --connect-timeout 10 "https://meet.$domain" > /dev/null 2>&1; then
            echo "âœ… Jitsi Meet is accessible at https://meet.$domain"
          else
            echo "::warning::Jitsi Meet at https://meet.$domain is not responding yet"
          fi
          
          # Check Matrix Synapse homeserver
          echo "Testing https://matrix.$domain ..."
          if curl -sSf -k --connect-timeout 10 "https://matrix.$domain/_matrix/client/versions" > /dev/null 2>&1; then
            echo "âœ… Matrix Synapse is accessible at https://matrix.$domain"
          else
            echo "::warning::Matrix Synapse at https://matrix.$domain is not responding yet (may not be deployed if secrets not configured)"
          fi
          
          # Check Element Web client
          echo "Testing https://chat.$domain ..."
          if curl -sSf -k --connect-timeout 10 "https://chat.$domain" > /dev/null 2>&1; then
            echo "âœ… Element Web is accessible at https://chat.$domain"
          else
            echo "::warning::Element Web at https://chat.$domain is not responding yet (may not be deployed if secrets not configured)"
          fi
          
          # Check Traefik dashboard
          echo "Testing Traefik dashboard..."
          if curl -sSf --connect-timeout 10 "http://$ip:8080/api/overview" > /dev/null 2>&1; then
            echo "âœ… Traefik dashboard is accessible"
          else
            echo "::warning::Traefik dashboard is not responding"
          fi
          
      - name: Check WireGuard service
        run: |
          echo "ğŸ” Checking WireGuard VPN service..."
          ip="${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          
          # Check if WireGuard port is open
          if nc -z -w5 -u "$ip" 51820 2>/dev/null; then
            echo "âœ… WireGuard port 51820 is open"
          else
            echo "::warning::Cannot verify WireGuard port 51820 (UDP check may be unreliable)"
          fi
          
      - name: Health Check Summary
        run: |
          domain="${{ secrets.DOMAIN_NAME }}"
          ip="${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          
          echo "## ğŸ‰ Deployment Health Check Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** Deployment completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "**Server IP:** $ip" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸŒ Service URLs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Root Domain:** https://$domain" >> $GITHUB_STEP_SUMMARY
          echo "- **WireGuard UI:** https://vpn.$domain" >> $GITHUB_STEP_SUMMARY
          echo "- **Jitsi Meet:** https://meet.$domain" >> $GITHUB_STEP_SUMMARY
          echo "- **Matrix Synapse:** https://matrix.$domain" >> $GITHUB_STEP_SUMMARY
          echo "- **Element Web:** https://chat.$domain" >> $GITHUB_STEP_SUMMARY
          echo "- **Traefik Dashboard:** http://$ip:8080/dashboard/" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âš ï¸ Important Notes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- SSL certificates may take 5-10 minutes to provision" >> $GITHUB_STEP_SUMMARY
          echo "- Ensure DNS nameservers are updated at your registrar" >> $GITHUB_STEP_SUMMARY
      - name: Display connection information
        run: |
          echo "ğŸ‰ WireGuard VPN Server deployed successfully!"
          echo "ğŸ“ Server IP: ${{ needs.terraform.outputs.public_ip || needs.terraform-auto.outputs.public_ip }}"
          echo "ğŸŒ Domain: ${{ secrets.DOMAIN_NAME }}"
          echo ""
          echo "ğŸ” Service URLs:"
          echo "  ğŸ”’ WireGuard UI: https://vpn.${{ secrets.DOMAIN_NAME }}"
          echo "  ğŸ“¹ Jitsi Meet: https://meet.${{ secrets.DOMAIN_NAME }}"
          echo "  ğŸ’¬ Matrix Synapse: https://matrix.${{ secrets.DOMAIN_NAME }}"
          echo "  ğŸ—¨ï¸  Element Web: https://chat.${{ secrets.DOMAIN_NAME }}"
          echo "  ğŸ“Š Traefik Dashboard: https://${{ secrets.DOMAIN_NAME }}:8080/dashboard/"
          echo ""
          echo "âš ï¸  DNS Configuration Required:"
          echo "   Update nameservers at your domain registrar to:"
          echo "   - hydrogen.ns.hetzner.com"
          echo "   - oxygen.ns.hetzner.com"
          echo "   - helium.ns.hetzner.de"
          echo ""
          echo "ğŸ“ Note: Matrix services require GitHub Secrets to be configured:"
          echo "   - MATRIX_ADMIN_USER"
          echo "   - MATRIX_ADMIN_PASSWORD"
          echo "   - MATRIX_REGISTRATION_SECRET"
          echo "   - MATRIX_POSTGRES_PASSWORD"
